# DDD — The Misunderstood Mantra

Eric, it is a great honor and pleasure that I would find myself in the company of those invited to address you on the 15th anniversary of your _magnum opus_. I too, have been with this process for 15 years, and have watched as both of our ideas have grown. Meeting you at _DDD Europe_ was a highlight for me and was my first opportunity to learn from you first-hand. I still yearn for us to continue that process, and hope we will meet face-to-face again soon, In the mean time, this is like a letter to you that primes the pump for those discussions. I offer these ideas with the greatest rexpect and great expectations of what we'll learn together next.

## Foreword

When I spoke at DDD Europe in 2016, Eric Evans and I commisterated that few people really understand Domain-Driven Design (DDD). It fits the old joke about teenage sex: everybody is talking about it and wants to do it, very few are really doing it, and those that are are doing it badly. Even _I_ find myself scratching my head about it, and in talking to Eric, even _he_ would write the book differently today than when Addison-Wesley asked me to review it in its nascent days.

These reflections mark one perspective on fifteen years of the history of these ideas. Maybe fifteen years is too early to assess a work's place in history; that will take another ten years, at least, I think. But perhaps my current reflections can both give Eric pride in what he has accomplished and challenge him, along with his colleagues, to add new thoughts and insights to the existing base. Much of what I say here, I have no doubt that Eric already has on his mind. If so, so much the better.

## First Impressions
Back in 2002, one of the first things that struck me about Eric's book was that he wasn't just another fundamentalist of object-oriented programming. A domain view, particularly in design, 

The most important contribution that Eric has made, in my opinion, is to raise awareness of what he calls the _ubiquitous language_. Though it is not likely ubiquitous and is certiainly not a language, such a collection of words grounds the dialectic from which great design emerges.

But two things bothered me a bit about the book. One was it didn't evoke any of the massive domain analysis literature. In the canon of computer science domains delineate areas of focus or knowledge both in the application and solution sectors of the business. It takes good analysis to find domains that are resilient under program evolution, and the book wasn't attientive to that — though the area is well-trodden. Maybe I invested a bit of my ego in this perspective because of my own work in this area on Multi-Paradigm Design from four years earlier, which is a discipline way of doing what one might well call domain-driven design.

More broadly, the book seemed to evoke many of the same sentiments as one could find in XP, which was about five years old at the time. XP had consciously set off 180° out of phase with conventional wisdom, and that found it to be out of step with the prevailing wisdom of the time that it was good to engage end users in a process loosely called _analysis_, and to appreciate the business perspective before jumping into design. Instead, XP would use an on-site customer as an insurance policy against the possibility of any gap between user needs and developer fantasies. DDD found itself grounded in the nerd _zeitgeist_ of the time. It would embrace design while consciously distancing itself from analysis.

There is no denying that the analysis culture of that era was badly in need of a reboot. Broad practice still evidenced widespread practices we had associated with "waterfall development," though even by this time the term _waterfall_ had become a four-letter word with which few people would identify.  The world was starting to run _from_ waterfall. It was an uncomfortable era in which people had not yet identified a cause _to_ which they should run. Frameworks, patterns, and programming language features had exanded to fill the mindshare space of the time. There were certainly those who were waiting for the next method, and in particular a method that would scale beyond XP — which made no claims for being able to support anything beyond single-team developments, in the face of management realms from the previous era who still believed in scaling. (And, sadly, this is a perspective that has resurfaced in the methods world here some 15 years later.)

The new _zeitgeist_ had thrown out the proverbial baby with the bathwater. Much later research would in fact point out that the emperor's new extreme were as bad as those of the previous regime, as we would find in the landmark papers of Martin, Biddle, Noble, Abrahamsson, Siniaalto, and others. Martin found on-site customer to be "unsustainable." Many had found that TDD did not live up to its promises, including Abrahamsson and Siniaalto. But back in 2002, in the shadow of an Agile Manifesto that was scarcely a year old, it was almost Communist to say that you weren't agile, and you would certainly incur the wrath of the mainstream method talking heads of the era of your notion of "agile" did not include On-Site Customer and TDD, or if it whispered the term "analysis."

_Domain-Driven Design_ was properly aligned with this perspective, but the framing was decidedly un-XP-like. The book had all the trappings of a mature- well-thought-out and practiced approach with its own disciplines, artefacts and, notably enough, its own vocabularly. All of these gave the book a well-deserved air of authoritativeness. I think that what the agile folks had discarded in the analysis area, DDD tried to push back into design. We have learned over the years that it is folly to separate design, implementation and testing of complex software, and that was one of the first trappings of waterfall to go out the window. But the analysis / production dichotomy remained: for example, in Scrum, this dichotomy is personified in the Product Owner role. Here, in the DDD book, it seemed like there was an attempt to bring analysis concerns to the design table. And of course this is useful in theory, or in the hands of highly experienced and disciplined developers. Practice begs more moderation, and deserves to celebrate analysis more than the DDD book does but much less than one found in the prevailing practice of the era. As such, the DDD book was the product of a stormy, ongoing dialog. Eric decided to put a stake in the ground where he did, based on his experience. I can only think that his experience was uncharacteristically graced with developers and leadership who had keen insight or business knowledge, or both. In that case, _anything_ works, and the DDD world model was as good a way as any to structure the work.

I think it bears emphasizing that Eric was doing anything here but going with the flow. It's important for me to say that because, as someone who was skeptical of many of the pseudo-agile practices the late 20th century, it would be easy for me to lump Eric together with the rest of the opportunists on the basis of the overlap between his ideas and theirs. What he was proposing was radical to the agile folks in its degree of structure, and radical to the traditionalists in eschewing analysis. That he included disciplines, structures and vocuabulary who by their very nature flew in the face of the fashion of the time, says that Eric was motivated by something deeper than selling a book or seeking fame. I wouldn't get to know him personally until 2016: It was immediately obvious to me, and I think it is obvious to anyone who knows Eric, that the last thing he is seeking is glory. He is motivated out the feeling of having discovered something deep and right, and maybe something that not many people have discovered on their own. I may disagree with him on several points of his thesis, but it somehow doesn't matter. We share the same process of inquiry and the same motivations. That's enough for me. And it lays a foundation for the analysis and counterpoints here. But I do digress.

I have often thought of the DDD book from the perspective of the domain of complex system develoipment. My career has led me to study that domain as a phenomenon or object in its own right for the past 35 years. Over this time we have started to develop a theory, if one can call it that, of complex system development, and its theory borrows heavily on those outside our field such as Christopher Alexander, Peter Senge, and Russell Ackhoff. Scrum is one of the first modern methods to draw on that theory. But the DDD book was hit and miss about drawing on any theory that would transcend development culture and perhaps compensate for accidental differences in personal insight and experience. And, as any such thing drawn from one's own experience, it works some of the time and it doesn't work some of the time. Though different from XP it faced the same challenges of applicability.

There is an even broader insight to consider here that has nothing to do with Eric or with DDD per se, but which blankets our entire discipline and which should be reason for concern. As one example, consider domain-specific languages (_DSLs_, also known as _application-oriented languages_ or _AOLs_) were in broad use and were well-defined by the early 1990s. Martin Fowler had taken the time-honored notion of domain-specific languages and started using it in the sense of conventions embeeded in a program of an existing general-purpose language. There is a kernel of insight behind this to the degree that well-chosen identifiers in a nicely structured language makes the code easier to understand. Still, it's about more than the identifiers, as language is about how we structure the relationships between the words. Even most modern programming languages trace their syntax back to FORTRAN (declation, assignment) and the basic types and semantics of the popular languages are still the algebraic operators. While computing was originally about playing with numbers, we've come a long way, and true DSLs go beyond a mere vocabulary to a true language.

Languages have not only syntax, but semantics — and some of the most powerful semantics of a language lie in its idiomatic constructs. And most fascination with what has come to be called DSLs is at the level of vocabulary rather than language, and the concern at hand rather than the domain. So contemporary DSLs have become a thing of doodling or straining out the gnats of local expression while ignoring the camels of overall system structure. A language encodes a way of thinking about form, and much of the discipline of domain-oriented thinking is about the forms around which they organize. Expressing those forms in a suitable vocabulary is almost a footnote. The early 1980s tradition of AOLs and DSLs built languages from scratch to capture these fundamental forms, while the emperor's new DSLs use the same languages (grammar, syntax, and base semantics) while just giving you a new dictionary. It is a haunting parallel to the pretense that a ubiquitous language is either a language or ubiquitous.

Yet if you talk to a post-2000 new age nerd, they will refer back to the Fowler notion of DSLs if they know them at all. Perhaps the reason is that to do a great DSL requires an excrutiating analysis investment, and with analysis out of fashion, it became necessary to exapt the concept and create something else. Or it may be because DSLs tend to do very badly in domains that aren't rock-solid stable. The domain of mathematics is pretty stable so DSLs like Excel® do pretty well; the theory behind parser theory is sound and stable so *yacc* and *bison* don't change that much. (The frequent *antlr* changes are annoying and seem to amount to syntactic saccharin and catching up with status quo.) Yet the emperor's new DSLs aspire to be the heart of a DDD approach: they are design rather than analysis; they build on somewhat extensible languages to embrace the concept of a ubiquitous language; and unlike rock-solid languages like Excel or *yacc*, any coder can evolve the language at their convenience.

I think Eric tried to show us a North Star called a _domain_ that should serve as the oracle for our design decisions. One shouldn't casually change a DSL without consulting a domain. I feel that Eric's domains, for whatever reason, are more conventions than laws, and I have always liked the traditional domain analysis community (think Neighbors, Lai, Weiss, Parnas, and others) for being close to the almost immovable foundations of the businesses their software served. But they are certainly more axiomatic than a developer's daily sense of a term's importance, of how much they need to type to express a concept. and of the new age DSLs that seem little more than macros on steroids. And if his notion of domain missed the mark, his notion of ubiquitous language hits the bullseye — even if it is only about a vocabulary. Words mean things, and I think few people understand that like Eric does.

## Reflections
### Guild not the lily
I  spoke above of my f´rurstation in not being able to find a theoretic grounding for DDD ideas. It brings to mind a radical proposition: Perhaps, in fact, there is no theoretical grounding to program structure, any more than there is a formal grounding for structuring a building. Sure, a building must stand, and a program must compile and link, but those are more engineering concerns that concerns of science. Even from an empirical perspective it is difficult to tease out theories and principles of good design. And the book _does_ underscore those that we agree about, such as separation of concerns and attentiveness to APIs.

This rasies a question about whether there is a seperate, viable view of programming-as-craft that breaks with software engineering tradition. I for one hold many softrware engineering platitudes in minor contempt, but perhaps I should join Eric and encourage colleagues to take this disdain even further. Eric's book is a strange book in that, at first glance, it treats topics in the neighborhood of software engineering — most notably, those tried-and-true universals I mentioned above. Both the software engineering literature and Eric's book lack credible grounding for their core ideas, but that doesn't mean the ideas are wrong. And it's unlikely in either case that we will find universals.

In some way I may have fallen into the trap in the same way that we criticize the fundamentalists of object-orientation, top-down design, or waterfall. We have precious little evidence that any of them "work" or not. Waterfall put us on the moon. For example, I can view DDD as what formally is called a _single hierarchy system_. DDD seems to blur coding-time and run-time concepts (a good thing), but there is one perspective and philosophy that stands behind a single structure of bounded contexts. The problem is that they are bounded. Real boundaries rarely exist in the real world. The accounting department and the UX designers don't communicate through well-defined memos and protocols, or even through documents or well-structured meetings, but may exchange the most crucial market needs around the coffee machine, If there protocol is not well-delineated, the protocol of their software artifacts should be equally porous. 

## Bring Back Analysis
With the rise of agile I have unfortunately seen the rise of a disgusting form of hacking I call "green bar fever." It's based on a rapid-feedback Pavlovian cycle where people make changes to their code that are as minimal as possible, re-run the test, and pray for the Green Bar. They tweak the code more than the test — as though the test for some reason was written when they had taken the smart pills while the code was written when they had not — and often end adding to technical debt.

As computers have become faster and as almost all programmers have at least one high-powered machine sitting on their lap, we have sought increasing opportunities for automation. Great design thinkers from Taichi Ōno to Elon Musk have warned against the evils of too much automation, and there are plenty of data and models to support the fact that automation lowers quality and may increase rework. As Toyota removes robots from their assembly lines software engineers are automating more and more work. The tools and technologies of the new millenium are starting to take on the prestige that technlology held in the 1950s and 1960s, when we all envisioned robots cooking our meals for us within a few years,

DDD doesn't fall into this trap in an obvious way, but it has come to be understood as being in much the same space. It's about _design_ rather than _analysis_. I am currently building a new house. Picking a site takes years, Laying out the house on the site takes weeks or months. Choosing a floor plan and kibbitzing with the architect takes weeks. Selecting the appliances and materials takes quite a while. The house itself — a sturdy, Norwegian-designed Trelleborg log house — goes up in a couple of days. Software people instead completely throw away analysis (DDD explicitly has no room for the activity of analysis) and go right into design.

The belief, I think, is that software is soft enough and languages expressive enough that we can iterate our thought process in the implementation. Experience after experience, and the mere fact that we have the phrase "technical debt" in our vocabulary stand testimony to the folly of this perspetive. There _are_ viable "tools" to help those who want to be concrete: prototyping, set-based design, modeling, formal analysis, and a host of others. These things take nerds out of their comfort zone of Java, Python or Ruby. So they stay in the code. And they have crafted an image of DDD that cheers them on.

Programming languages and their design methods bring little insight into end-user needs, except in the case of domain-specific languages in the broad sense, rather that the narrow sense they have taken on as described above. In a new exposition of DDD into the wild, it woiuld be good to acknowledge the place of sound analysis, or at least domain expertise, as a companion to the good design practices that are already there.

## By, of, and for the people
I went to a workshop session at the DDD conference where people were talking about software that helped in the maintenance of factory floor machinery. I decided to apply an old test. I sat and quietly listened to their conversation and observed how long it would take for me to find out what business they were in, They were discussing their ubiquitous language, so I thought: This should be easy, I listened. The talked about *entities* (which I figured out were things like machines) with *components* (motors, belts, bearing assemblies) and *associations* (pipes, tubes, and wires connecting the machines) and so many other nerd-centric concepts that I eventually had to ask what these machines actually built. But _motors_, _wires_, and specifie _machines_ were menitoned only in passing as though such use would somehow sully or corrup design understanding. It was design without analysls.

Several months later I would travel to China to serve a client that wanted advice on DDD. They told me they had contacted Eric but that Eric really didn't want to travel to China; besides, he had written a book that conveyed enough of his knowledge that he didn't have to be there in person. I sat through hours of PowerPoint presentations of UML diagrams of design: classes, class hierarchies, and associations. Most of the workers were 20-somethings with a few months or, occasionally, a few years of experience. There had been no concerted effort to canvass the market, to make a domain model (i.e., an enumeration of the business domains and an understanding of their relationships). They could not tell me what problem they were solving. It was nerd heaven.

To make anallysis work means mixing with the hoi-polloi: of getting one's fingers dirty and understanding the non-hierarchical messiness of the real world. DDD structure is a hierarchy (or, at best, a directed acyclic graph) with perfect symmetry. Its symmetry gives it elegance, and that elegance appeals to the analytical mind. Our mind uses the approximate symmetry of nature to cheat how memory works, to save energy: when I meet you., my mind stores away an image of only half your face. Yet if you carefully analyze a picture of yourself, you'll find you're not symmetric. (Take a picture of your face, straight on; make two copies, and cut each copy into perfect halves, right down the nose. Put the halves together in various ways to see the many versions of You.) Yet architect Christopher Alexander reminds us that beauty owes to the breaking of symmetry and to harmonizing with the inevitable imperfections of nature. Many, such as Jef Raskin (_Humane Interfaces_), admonish us to create software tolerant of human frailty and errors.

## Mental Models
One negative, to me, is that DDD talks very little about people. Most software today interacts with an end user, and it's crucilal that the underlying software structure, the elements of the human interface, and the end-user mental model be well-aligned. DDD seems like the nerds' revenge, sitting inside the machine, unbothered by human beings.

If the mental model could steer or more directly drive how we create bounded contexts, I think we would end with systems that have fewer bugs, that evolve better, and that are easier to understand. These concerns are often far from the design considerations that one can express in a programming language or even in a DSL in its new sense. They are an issue of analysis and model-building that long precedes even the selection of a programming language.

The new house I am building will lie in nature amongst sand dunes close to the sea. We talked to many who have built homes in the area about how their layout deals with the usual blustery weather and occasional sandstorm; how the foundations will work with the sand-and-turf layer soil; how to take advantage of the incredibly unique light for which the area is world-famous, and so forth. It wasn't just lookig at house floor plans, picking one that was spacious and easy to clean and plopping it down on our property. I bought a drone and we did aereal surveys. We prototyped several layouts on our lot. None of these things would have come from the architect's drawings or from his drafting tools. And so it is in software. It is critical to tie the overall system form, as well as the design of its parts, to the mental model of the user. DDD talks about objects: getting the end user mental model into the software is the whole reason OO was created. DDD talks about patterns: letting the inner feeling of the _habitants_ of the dwelling attune their instincts and to drive the design is the whole Alexandrian agenda.


## Break the Symmetry
DCi. I spoke of it at the conference.

Eric's book often uses patterns as expository structures. This is one case where I believe the theory could be priceless in moving to the next stage, Pattern theory is all about interaction between and not-separateness of the things we create. Alexander himself uses the phrase "not-separateness" often, and is known for his essay "A City is Not a Tree" that decries urban plannin based on delineated neighborhoods — their bounded contexts. Patterns go beyond DCI in that DCI only breaks two (or maybe three) dimensions of symmetry. They are multitude. The designer who ignores them will produce an inhmane system.

Many idiomatic language constructs are a form of symmetry breaking. Copying an array in C, a novice would do like this:

char array1[10], array2[10];
. . .
for (int i = 0; i < 10; i++) {
   array1[i] = array2[1];
}

But that is just syntax and semantics compliant with (symmetric to) the canonical grammar of the language., If we mix several linngistic constructs, we get:

char array1[10], array2[10];
. . .
char *cp1 = array1, *cp2 = array2;
while (*cp1++ = @cp2++);

True richness of exoressiion comes in concept overlap. For example, in flight reservations, there is a´high overlap between routes and XXX.


## Domain Specific Languages
Make the ubiquitous language more ubiquitous. S for statisticians or Excel or PowerPoint.


## A Taxonomy of Theory and Heuristics
Too often comouter scientists seek overly deeo rationalizations or overly formal reasons for their code. We can analyze user needs to death. But as Freud says, sometimes a cigar is just a cigar.

Sometimes, disjoint bounded contexts are just the ticket. While nothing in the universe is perfectly separate from anything else, somtimes the separation is good enough that each concept can have its own self-contained entity. There is a time and place for such separations, perhaps at the grossest llevel of scale (separating the missle navigation software from the program that controls the hydraulics of the radar antenna) and the finest (a String is a pretty high-integrity concept.)

Yet things are messy in between, and the symmetry breaks. We need both heuristics and design formalisms to decide when to create new entities and when to use more sophisticated approaches such as DCI. Sometimes culture wins out and what is in reality an entangled concept deserves its own identity because of how it matches human mental models. Perhaps such situations should cause us to cast Occam's Razor aside for the sake of pragmatics abd the power of software maintainability that comes with comprehension. A true story is useless if it cannot be understood, and even untrue stories (fables, myths) convey great power.



