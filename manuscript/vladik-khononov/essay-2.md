# The Missing Link

Let’s be honest: our industry’s track record is pretty bad. The vast majority of software projects fail because they do not meet the budget or timeframe or deliver the expected value. Much research has been conducted to identify the reasons for these failures, and the results vary. However, if we look at those findings, one central theme repeats itself over and over: communication. It’s either stated explicitly — “poor communication” – or implicitly, by describing outcomes:

* “Badly defined system requirements”
* “Poor reporting of the project's status”
* “Unarticulated project goals”
* “Project managers don’t understand users’ needs”
* “Project changes are managed poorly”
* Etc.

Nothing is really surprising here. For years we’ve been trying to introduce different ways to improve the effectiveness of communication: agile methodologies, wikis, chats, and even controversial solutions such as putting everyone in open spaces. But did we manage to improve our success rates? No. 

Additional communication mediums haven’t solved our communication problems. Projects keep failing. We have to look for solutions elsewhere.

## Ubiquitous Language

The cornerstone practice of the Domain-Driven Design methodology calls for cultivation of one language that can be spoken by businesspeople, software engineers, and even source code: Ubiquitous Language.

The first benefit of having such a language is obvious. Translating businesspeople’s mental models into software requirements, and those requirements into technical jargon for engineers, is nothing but a Chinese whispers game. Having a rigorous ubiquitous language eliminates the need for such translations! Software engineers needn’t depend on business analysts to interact with domain experts; they can converse with them directly. More than that, those domain experts can make sense of the system’s source code. The result? Both engineers’ mental models and the source code align much better with the businesspeople’s way of thinking. Hence, there are fewer communication issues, and the resulting codebase becomes much easier to maintain and extend.

Another benefit of having a ubiquitous language is more subtle. We all know the importance of feedback loops. Agile, Lean, DevOps - all these notions are intended to accelerate different feedback loops. Why are feedback loops so important? Well, because they facilitate communication! The process of cultivating a ubiquitous language is just another feedback loop. Hence, by increasing the frequency of communication, the quality of communication continually improves as well.

## Conclusion

I’d like to conclude this essay with a quote from one of the brightest minds of our time:

> “If I had an hour to solve a problem I'd spend 55 minutes thinking about  the problem and 5 minutes thinking about solutions” - Albert Einstein

I argue that ubiquitous language is our industry’s missing link. It is the quickest and safest way to truly understand the problems we are solving. Hence, we have to employ this powerful tool on each and every software endeavor.

## References

* “Domain-Driven Design: Tackling Complexity in the Heart of Software”, Eric Evans
* “Why Software Fails", Robert N. Charette
* “Critical Success Factors In Software Projects”, John S. Reel
* “An Investigation of Failure in Information Systems Projects: The Case of Jordan”, Rateb J. Sweis
* “Critical failure factors in information system projects”, K.T. Yeo
* “Critical success factors for software projects: A comparative study”, Mohd Hairul Nizam Nasir and Shamsul Sahibuddin
* “Seven Reasons Why Information Technology Projects Fail”, Joseph Gulla, Ph.D.