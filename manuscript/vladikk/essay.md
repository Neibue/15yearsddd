> This essay is based on my talk “7 Years of DDD: Tackling Complexity in Large-Scale Marketing Systems”. It was delivered at Explore DDD, DDD Europe, KanDDDinsky, NDC Sydney, and other conferences.

# 7 Years of DDD: Tackling Complexity in Large-Scale Marketing Systems

One morning, back in 2010, I got a phone call from a friend. He said he was starting a new company. The business was not going to be simple, but if I joined him, from the technical perspective I could do whatever I wanted. I agreed to join him, just like that! 

In this essay I’d like to share what I got myself into. In particular, the Domain-Driven Design (DDD) side of our company’s story, since we employed this methodology from day one. 

I’ll start with a walk through the stories of 5 Bounded Contexts that demonstrate the different approaches to DDD we tried, and the results of our efforts. In the second part, I will use those 5 stories to share some practical advice on domain-driven design, domain modeling, event sourcing, CQRS, and microservices, all based on our experience at Internovus.

But first, as well-behaved DDD practitioners, we’ll start with the business domain.


### Internovus
Imagine you are producing a product or a service. Internovus allows you to outsource all of your marketing-related chores. We will come up with the best marketing strategy for your product. Our copywriters and graphic designers will produce tons of creative materials, such as banners and landing pages, that will be used to run advertising campaigns that promote your product. All the leads generated by these campaigns are handled by our own sales agents, who will make the calls and sell your product.

Most importantly, this marketing process provides many opportunities for optimization, and that’s exactly what our analysis department is doing. They analyze all the data to make sure our clients are getting the biggest bang for their buck, be it by pinpointing the most successful campaigns, the most effective creatives, or by ensuring that the sales agents are working on the most promising leads.

![Internovus](images/vladikk/hand-drawn/1-internovus.png)

### A New Hope
Since we were a self-funded company, we had to get rolling as fast as possible. Therefore, for the first version, we had to implement the first third of our value chain:
* A system for managing contracts and integrations with external publishers;
* A catalog for our designers to manage creative materials; and 
* A campaign management solution to run advertising campaigns.

The latter meant not only an information management system, but an advertisement serving and hosting solution as well. To be honest, I was overwhelmed and had to find a way to wrap my head around all the complexities of the business domain. Fortunately, not long before we started working, I got a book that promised just that. It described a way to tackle the complexities at the heart of software: Domain-Driven Design.

Surely The Blue Book reads like poetry[^poetry], but it is not an easy book to read. Luckily for me, I got a really strong grasp of domain-driven design just by reading the first four chapters.

Guess how the system was initially designed? — It would definitely make a certain prominent individual from the DDD community proud.

![@DDD_Borat](images/vladikk/hand-drawn/2-borat.png)

[^poetry]: <https://www.infoq.com/interviews/jimmy-nilsson-linq>

## Part 1: 5 Bounded Contexts

### The First “Bounded” Context
The architectural style of our first solution could be neatly summarized as “Aggregates Everywhere”. Agency, Campaign, Placement, Funnel, Publisher - each and every noun in the requirements was proclaimed as an Aggregate.

All those so-called aggregates resided in a huge, lone, bounded context. Yes, a big scary monolith, the kind that everyone warns you about nowadays.

And of course, those were no aggregates. They didn’t provide any transactional boundaries, and they had almost no behavior in them. All the business logic was implemented in an enormous service layer. A typically anemic domain model.


![Anemic Domain Model](images/vladikk/hand-drawn/3-anemic-dm.png)

In hindsight, this design was so terrible it resembled a by-the-book example of what domain-driven design is not. However, things looked quite different from the business standpoint.

From the business’s point of view, this project was considered a huge success! Despite the flawed architecture, and despite our unique approach to quality assurance — QA is for cowards — we were able to deliver working software in a very aggressive time to market. How did we do it?

#### A Kind of Magic
We somehow managed to come up with a robust Ubiquitous Language. None of us had any prior experience in online marketing, but we could still hold a conversation with domain experts. We understood them, they understood us, and to our astonishment, domain experts turned out to be very nice people! They genuinely appreciated the fact that we were willing to learn from them and their experience.

The smooth communication with domain experts allowed us to grasp the business domain in no time and to implement its business logic. Yes, it was a big scary monolith, but for two developers in a garage it was just good enough. Again, we produced working software in a very aggressive time to market.

#### Domain-Driven Design
Our understanding of domain-driven design at this stage could be represented with this simple diagram:

![](images/vladikk/hand-drawn/4-ddd.png)

Ubiquitous language and an anemic domain model, in a monolithic bounded context.

### Bounded Context #2: CRM
Soon after we deployed the campaign management solution, leads started flowing in, and we were in a rush. Our sales agents needed a robust CRM[^crm] system.

The CRM had to aggregate all incoming leads, group them based on different parameters, and distribute the leads across multiple sales desks around the globe. It also had to integrate with our clients’ internal systems, both to notify the clients about changes in the leads’ lifecycles and to complement our leads with additional information. And, of course, the CRM had to provide as many optimization opportunities as possible. For example, we needed the ability to make sure that the agents were working on the most promising leads, to assign leads to agents based on their qualifications and past performance, and to allow a very flexible solution for calculating agents’ commissions.

Since no off-the-shelf product fit our requirements, we decided to roll out our own CRM system.

[^crm]: <https://en.wikipedia.org/wiki/Customer-relationship_management>

#### More Aggregates!
The initial implementation approach was the good ol’ DDD Lite. We decided to call every noun an aggregate, and shoehorn them into the same monolith. This time, however, something felt wrong right from the start.

We noticed that, all too often, we were adding awkward prefixes to those “aggregate” names - like CRMLead and MarketingLead, MarketingCampaign and CRMCampaign. Interestingly, we never used those prefixes in conversations with domain experts — somehow, they always understood the meaning from the context. Then it dawned on me: there was a chapter with something about contexts in the Big Blue Book. This time, I read it cover to cover. 

#### Achievement Unlocked: Read the Blue Book
I learned that bounded contexts solve exactly the same issue we had experienced — they protect the consistency of the ubiquitous language.

By that time, Vaughn Vernon had published his “Effective Aggregate Design”[^vernon] paper. After reading it, I finally understood that aggregates aren’t just data structures; they play a much larger role by protecting the consistency of the data.

We took a step back, and redesigned the CRM solution to reflect these revelations.

[^vernon]: <http://dddcommunity.org/library/vernon_2011/>

#### Solution Design: Take #2
We started by dividing our monolith into two distinct bounded contexts: Marketing and CRM. We didn’t go all the way to microservices here, or anything like that. We just did the bare minimum to protect the ubiquitous language.

However, in the new bounded context — CRM — we were not going to repeat the same mistakes we did in the Marketing system. No more anemic domain models! Here we would implement a real domain model with real, by-the-book aggregates. In particular, we vowed that:
* Each transaction would affect only one instance of an aggregate;
* Instead of an OR/M, each aggregate itself would define the transactional scope; and 
* The service layer would go on a very strict diet, and all the business logic would be refactored into the corresponding aggregates.

We were so enthusiastic about doing things the right way – but, soon enough, it became apparent that modeling a proper domain model is damn hard!

#### First Blood
Relative to the Marketing system, everything took much more time! It was almost impossible to get the transactional boundaries right the first time. We had to evaluate at least a few models and test them, only to figure out later that the one we hadn’t thought about was the correct one. The price of doing things the “right” way was very high — lots of time.

Soon it became obvious to everyone that there was no chance in hell we would meet the deadlines! To help us out, the management decided to offload implementation of some of the features to ... DBAs.

Yes, stored procedures.

This single decision resulted in much damage down the line. Not because SQL is not the best language for describing business logic. No, the real issue was a bit more subtle and fundamental.


#### Babel Tower 2.0
This situation produced an implicit bounded context whose boundary dissected one of our most complex business entities: the Lead.

The result was two teams working on the same business component and implementing closely related features, but with minimal interaction between them. Ubiquitous language? Give me a break! Literally, each team had its own vocabulary to describe the business domain and its rules.

#### Achievement Unlocked: Slapped by Conway’s Law
The models were inconsistent. The was no shared understanding. Knowledge was duplicated, the same rules were implemented twice. Rest assured, when the logic had to change, the implementations went out of sync immediately.

Needless to say, the project wasn’t delivered anywhere near on time, and it was full of bugs. Nasty production issues that had flown under the radar for years corrupted our most precious asset — our data.

The only way out of this mess was to completely rewrite the Lead aggregate, this time with proper boundaries, which we did a couple of years later. It wasn’t easy, but the mess was so bad there was no other way around it.

#### Domain-Driven Design
Even though this project failed pretty miserably by business standards, our understanding of domain-driven design evolved a bit: build a ubiquitous language, protect its integrity using bounded contexts, and instead of implementing an anemic domain model everywhere, implement a proper domain model everywhere.

![](images/vladikk/hand-drawn/5-ddd.png)

#### A Missing Piece?
Of course, a crucial part of domain-driven design was missing here: subdomains, their types, and how they affect a system’s design. 

Initially we wanted to do the best job possible, but we ended up wasting time and effort on building domain models for supporting subdomains. As Eric Evans put it, not all of a large system will be well designed. We learned it the hard way, and wanted to use the acquired knowledge in the next project.

### Bounded Context #3: Event Crunchers
After the CRM system was rolled out, we suspected that an implicit subdomain was spread across Marketing and CRM.

Whenever the process of handling incoming customer events had to be modified, we had to introduce changes both in the Marketing and CRM bounded contexts.

Since conceptually this process didn’t belong to any of them, we decided to extract this logic into a dedicated bounded context called Event Crunchers.

![](images/vladikk/hand-drawn/6-crunchers.png)

#### Solution Design
Since we didn’t make any money out of the way we move data around, and there weren’t any off-the-shelf solutions that could have been used, Event Crunchers resembled a supporting subdomain. We designed it as such.

Nothing fancy this time: just layered architecture and some simple ETL-like transaction scripts. This solution worked great, but only for a while.

#### The Ball Started Rolling
As our business evolved, we implemented more and more features in the Event Crunchers. It started by BI people asking for some flags – a flag to mark a new contact, another one to mark various first-time events, some more flags to indicate some business invariants, etc.

Eventually those simple flags evolved into a real business logic, with complex rules and invariants. What started out as an ETL script evolved into a fully-fledged core business domain. 

Unfortunately, nothing good happens when you implement complex business logic as ETL scripts. Since we didn’t adapt our design to cope with the complex business logic, we ended up with a very big ball of mud. Each modification to the codebase became more and more expensive, quality went downhill, and we were forced to rethink the Event Crunchers design. We did it a year later.


#### Design: Take #2
By that time, the business logic became so complex that it could only be tackled with Event Sourcing. We refactored Event Crunchers’ logic into an event-sourced domain model, with other bounded contexts subscribing to its events.

Interestingly, we had both similar and different experiences in another project.

### Bounded Context #4: Bonuses
One day, the sales desk managers asked us to automate a simple, yet tedious procedure that they had been doing manually: calculating the commissions for the sales agents.

#### Implementation
Again, it started out simply - once a month, just calculate a percentage of each agent’s sales, and send the report to the managers. As before, we contemplated whether his was our core business domain. The answer was no. We weren’t inventing anything new, weren’t making money out of this process, and if it was possible to buy an existing implementation, we definitely would. Not core, not generic, but another supporting subdomain. 

We designed the solution accordingly: some Active Record objects, orchestrated by a “smart” service layer:

![Bonuses Architecture](images/vladikk/hand-drawn/7-supporting.png)

Once the process became automated, boy, did everyone become creative about it.

#### Creativity Unleashed
Our analysts wanted to optimize the heck out of this process. They wanted to try out different percentages, to tie percentages to sales amounts and prices, to unlock additional commissions for achieving different goals, etc., etc. Guess when the initial design broke down? 

Again, the codebase started turning into an unmanageable ball of mud. Adding new features became more and more expensive, bugs started to appear – and when you’re dealing with money, even the smallest bugs can have BIG consequences.

#### Design: Take #2
As with the Event Crunchers project, at some point we couldn’t bear it anymore. We had to throw away the old code and rewrite the solution from ground up, this time as an event-sourced domain model.

Just as in Event Cruncher, the business domain was initially categorized as a supporting one. As the system evolved, it gradually mutated into a core business domain: we found ways to make money out of these processes. However, there is a striking difference between these two bounded contexts.

#### “Same Same, But Different”
For the Bonuses project, we had a ubiquitous language. Even though the initial implementation as based on Active Records, we could still have a ubiquitous language. 

As the domain’s complexity grew, the language used by the domain experts got more and more complicated as well. At some point, it could no longer be modeled using Active Records! This realization allowed us to notice the need for a change in the design much earlier than in the case of the Event Crunchers. We saved a lot of time and effort by not trying to fit a square peg in a round hole, thanks to the ubiquitous language.

#### Domain-Driven Design
At this point, our understanding of domain-driven design had finally evolved into a classic one: ubiquitous language, bounded contexts, and different types of subdomains, each designed according to its needs.

![](images/vladikk/hand-drawn/8-ddd.png)

However, things took quite an unexpected turn for our next project.

### Bounded Context #5: The Marketing Hub
Our management was looking for a profitable new vertical. They decided to try using our ability to generate a massive number of leads, and sell them to smaller clients, ones we hadn’t worked with before. 

This project was called “Marketing Hub”.

#### Design
Since this business domain was defined as a new profit opportunity by management, it was clearly a core business domain. Hence, design-wise, we pulled out the heavy artillery: Event Sourcing and CQRS. Also, back then, a new buzzword — microservices — started gaining lots of traction. We decided to give it a try.

This is what our solution looked like:

![](images/vladikk/hand-drawn/9-microservices.png)

Small services, each having its own database, with both synchronous and asynchronous communication between them. On paper, it looked like a work of art. In practice, not so much.

#### Micro-what?
We naively approached microservices thinking that the smaller the service, the better. So we drew service boundaries around the aggregates. In DDD-lingo, each aggregate became a bounded context on its own. 

Again, initially this design looked great. It allowed us to implement each service according to its specific needs. Only one would be using Event Sourcing, and the rest would be state-based aggregates. Moreover, all of them could be maintained and evolved independently.

However, as the system grew, those services became more and more chatty. Eventually, almost each service required data from all the other services to complete some of its operations. The result? What was intended to be a decoupled system ended up being a distributed monolith. And an absolute nightmare to maintain.

Unfortunately, there was another, much more fundamental issue we had with this architecture. To implement the Marketing Hub, we had used the most complex patterns for modeling the business domain: Event Sourcing and Domain Model. We carefully crafted all those services. But it all was in vain.

#### The Real Problem
Despite the fact that Marketing Hub was considered a core domain by the business, it had no technical complexity in it. Behind that complex architecture stood a very simple business logic – so simple that it could have been implemented using plain active records.

As it turned out, the business people were looking to profit by leveraging our existing relationships with other companies, and not through the use of clever algorithms.

The technical complexity ended up being much higher than the business complexity. To describe such discrepancies in complexities, we use the term “accidental complexity”, and our initial design ended up being exactly that. The system was over-engineered.

### Bounded Contexts: Summary
Those were the five bounded contexts that I wanted to tell you about: Marketing, CRM, Event Crunchers, Bonuses, and Marketing Hub.

I know, it might sound like we’re a bunch of losers who can’t do anything right the first time. But fear not: I wanted to share the stories of the bounded contexts we learned the most from. And that brings us to the second part. Let’s see what we learned from this experience.

## What We Learned

### Ubiquitous Language
In my opinion, ubiquitous language is the “core domain” of domain-driven design. The ability to speak the same language with our domain experts has been indispensable to us. It turned out to be a much more effective way to share knowledge than tests, documents, and “even” Jira.

Moreover, the presence of a ubiquitous language has been a major predictor of a project’s success for us:
* When we started, our implementation of the Marketing system was far from perfect. However, the robust ubiquitous language compensated for the architectural shortcomings and allowed us to deliver the project’s goals.
* In the CRM context, we screwed it up. Unintentionally, we had two languages describing the same business domain. We strived to have a proper design, but because of the communication issues we ended up with a huge mess.
* The Event Crunchers project started as a simple supporting subdomain, and we didn’t invest in the ubiquitous language. We regretted this decision big time when the complexity started growing. It would have taken us much less time if we initially started with a ubiquitous language.
* In the Bonuses project, the business logic became more complex by orders of magnitude, but the ubiquitous language allowed us to notice the need for a change in the implementation strategy much earlier.

Hence, our take on it right now: ubiquitous language is not optional, regardless of whether you’re working on a core, supporting, or even a generic subdomain.

#### Invest Early!
We also learned the importance of investing in the ubiquitous language as early as possible. It is practically impossible to “fix” a language if it has been spoken for a while in a company (as was the case with our CRM system). We were able to fix the implementation. It wasn’t easy, but eventually we did it. That’s not the case, however, for the language. To this day, some people still use the conflicting terms defined in the initial implementation.

### Lesson #2: Subdomains
We all know that, according to domain-driven design, there are three types of business domains:

#### Core Subdomains
Things the company is doing differently from its competitors to gain competitive advantage. In our case, we came up with our unique way to optimize the lifecycle of advertising campaigns. We also built our own CRM solution to make sure that we could measure and optimize each step in the process of handling incoming leads.

As we saw earlier, both Bonuses and Event Crunchers became our core subdomains, since we found ways of using those systems to gain additional profits.

#### Supporting Subdomains
The things the company is doing differently from its competitors, but that do not provide any competitive advantage.

A good example of a supporting subdomain in our company is the Creative Catalog. We implemented our own solution for managing creative materials – not because storing those files in a particular way made us more profitable, but because we had to – without it we couldn’t deliver our campaign management and optimization solution.

#### Generic Subdomains
Generic subdomains are all the things that all companies do in the same way. Those are the solved problems. For example, like all companies, we had to manage our systems’ users. We could have implemented our own solution. It would definitely have taken us a long time and loads of effort. I’m sure that, security-wise, our solution wouldn’t have been ideal. And even if it was 100% secure, it still wouldn’t affect the company’s profits in any way. That’s why it’s preferable to use a common, battle-proven solution.

#### Subdomain Type → Implementation Strategy
It is a common practice to use this categorization in business domains to drive design decisions:
* For the core subdomains, use the heavy artillery: domain-driven design’s tactical patterns, or Event Sourcing;
* Supporting subdomains can be implemented with a rapid application development framework; and 
* Generic subdomains, in almost all cases, are cheaper and safer to buy or adopt than to implement yourself.

However, this decision model didn’t work well for us.

Companies, and especially startups like ours, tend to change and reinvent themselves over time. Businesses evolve, new profit sources are evaluated, other neglected, and sometimes unexpected opportunities are discovered. Consequently, business domain types change accordingly. 

Speaking of our company, we have experienced almost all the possible combinations of such changes:
* Both the Event Crunchers and Bonuses started as supporting subdomains, but once we discovered ways to monetize these processes, they became our core subdomains.
* In the Marketing context, we implemented our own Creative Catalog. Nothing really special or complex about it. However, a few years later, an open-source project came out that offered even more features than we originally had. Once we replaced our implementation with this product, a supporting subdomain became a generic one.
* In the CRM context, we had an algorithm that identified the most promising leads. We refined it over time and tried different implementations, but eventually it was replaced with a fully managed machine learning model running on AWS. Technically, a core subdomain became generic.
* As we’ve seen, our Marketing Hub system started as a core, but ended up being a supporting subdomain, since the competitive edge resided in a completely different dimension.
* We also have quite a few examples in our industry of companies that turned generic and supporting subdomains into their core business. For example, Amazon and their AWS Cloud. 
 Once this kind of change in a subdomain type happens, its design should evolve accordingly. Failing to do so in time will lead to blood, tears, and accidental complexities. Hence, instead of making design decisions based on subdomain types, we prefer to reverse this relationship.

#### Implementation Strategy → Subdomain Type
For each subdomain, we start by choosing the implementation strategy first. No gold-plating here: we want the simplest design that will do the job.

![](images/vladikk/hand-drawn/10-design-to-type.png)

Next, from the selected design, we deduce the subdomain’s type. This approach has multiple benefits.

#### Benefit #1: Less Waste
The implementation is driven by the requirements at hand. It’s not going to be over-engineered, as in the case of the Marketing Hub, and it won’t be under-engineered, as in the case of the Bonuses project.

#### Benefit #2: Dialog
Second, reversing this relationship creates additional dialog between you and the business. Sometimes, business people need us as much as we need them.

If they think something is a core business, but you can hack it in a day, then questions should be raised about the viability of that business.

On the other hand, things get interesting if a subdomain is considered as a supporting one by the business but can only be implemented using advanced modeling techniques:
* First, the business people may have gotten over-creative with their requirements and ended up with accidental business complexity. It happens. In such a case, the requirements can, and probably should, be simplified.
* Second, it might be that the business people don’t yet realize that they employ this subdomain to gain an additional competitive edge. (This happened in the case of the Bonuses project.) By uncovering this mismatch, you’re helping the business to identify new profit sources much faster.
* 
But how do you choose the implementation strategy? At Internovus, we’ve identified a couple of very simple heuristics that allow us to streamline this decision-making process.

### Tactical Heuristics
To choose an implementation strategy for a business subdomain, you have to decide how to model its business logic in code. For that we have four options, four patterns:

#### Business Logic Modeling Patterns

##### Transaction Script
This pattern calls for implementing the business logic as a simple and straightforward procedural script. Nothing fancy or complicated. All you have to take care of is to make sure each operation is transactional: it either succeeds or fails. Hence the name — Transaction Script.

##### Active Record
Here we still have the same procedural code; however, instead of accessing databases directly, it operates on objects that abstract the persistence mechanism - active records.

##### Domain Model
I will use Domain Model as an overarching name for domain-driven design’s tactical patterns, such as aggregate, value object, service, etc.

##### Event Sourced Domain Model
This pattern is based on the domain model, but here we are using event sourcing to represent changes in aggregates’ lifecycles.

#### Heuristics
You can decide which modeling pattern you should use by answering a number of questions about the business domain:
* Does the domain in question deal with money directly, require deep analytics or an audit log? If it does, use the event-sourced domain model.
* How complex is the business logic? Is it more complex than some input validations? Does it have complicated business rules and invariants? If it does, use the domain model.
* If the business logic is simple, then how complex are the data structures? If it includes complicated object relations or trees, implement the active record pattern.
* Lastly, if the answers to all those questions are negative, use a simple transaction script.


#### Architectural Patterns
Once you’ve decided how to model the business domain, mapping an architectural pattern is trivial:
* You need CQRS to implement event-sourced domain model.
* Domain model requires hexagonal architecture.
* Use layered architecture for active record.
* For transaction script, in many cases, you can even do without layers.

_The only exception here is CQRS, as it can be useful for any of these patterns. But that’s the next topic we’re going to discuss._

Let’s say you’ve chosen an implementation strategy, but over time it started breaking under its own weight. For example, you’ve been using the active record pattern, but maintaining the business logic became painful. This “pain” is a very important signal. Use it!

#### Don’t Ignore Pain
It means that the business domain has evolved. It’s time to go back and rethink its type and implementation strategy. If the type has changed, talk with the domain experts to understand the business context. If you do need to redesign the implementation to meet new business realities, don’t be afraid of this kind of change. Once the decision of how to model the business logic is made consciously and you’re aware of all the possible options, it becomes much easier to react to such a change, and to refactor the implementation to a more elaborate pattern.

Let’s talk a bit more in-depth about CQRS.

### Lesson #4: CQRS
Historically, CQRS is closely related to event sourcing. If you’re doing event sourcing, in almost all cases you need CQRS. However, it is crucial to understand that event sourcing and CQRS are not the same. Instead, they are two conceptually different patterns.

#### CQRS is not Event Sourcing
Event sourcing is a way to model the behavior of a business domain. CQRS, on the other hand, is an architectural pattern. It allows you to represent the same data in different persistent models. For example, in case of event sourcing, you have the event store for writing and projections for reading — the same data, but persisted in different models.

We found that CQRS can be very beneficial for all kinds of business domains, even those implemented as simple transaction scripts or active records. In such cases, we built the projections out of the persisted state. We called them state-based projections. 

#### State Based Projections
The idea is the same as materialized views in relational databases, the difference being that we project additional models into other types of databases.

For example, in the Creative Catalog we used a relation model to represent the creatives. However, the data was projected into a search index(Elasticsearch) and plain files in S3 for caching:

!!!! DIAGRAM demonstrating catch-up subscriptions via row-version !!!!

What makes this implementation of CQRS, and not a mere data replication, is the fact that we used the same infrastructure to project additional models. It always allowed us to plug in new types of projections in the feature or to wipe and rebuild existing ones.

#### Relaxed Segregation
We all know that the CQRS pattern originated from the CQS principle. However, in our experience, clinging too tightly to the CQS roots resulted in nothing but accidental complexity. Let me explain.

Originally, we tried to keep our commands “void”, i.e. not returning any data. The more we did it, the more we struggled, until finally we realized that it made little sense. When a user or a system executes a command, they need to know its outcome: 
* Whether the command succeeded or failed.
* If it failed — why? Were there any validation issues? Or was there a technical issue? 
* If it succeeded, the user experience may be improved by reflecting the updated data back in the UI.

We didn’t find any reasons that prevented us from returning this information as a command’s result. We did, however, segregate the models: since projections are eventually consistent, all the data returned by the command should originate from the strongly consistent “write” model:

!!! Diagram !!!!

### Bounded Contexts’ Boundaries
At Internovus, we’ve tried quite a few strategies for setting the boundaries of bounded contexts:
* Linguistic boundaries: We split our initial monolith into Marketing and CRM contexts to protect their ubiquitous languages;
* Subdomain-based boundaries: Most of our subdomains were implemented in their own bounded contexts – for example, Event Crunchers and Bonuses.
* Entity-based boundaries: As we discussed earlier, this approach had limited success in the Marketing Hub project, but it worked well in others. For example, later on we extracted some of the entities out of Marketing into their own bounded contexts.
* Suicidal boundaries: As you may remember, in the initial implementation of the CRM we dissected an aggregate into two different bounded contexts. Don’t ever try this at home, okay?

Which of these strategies is the recommended one? Neither one fits all cases. Let’s see why.

#### Heuristics
As Udi Dahan pointed out, finding boundaries is really hard — there is no flowchart for that! This statement has profound implications. Since there is no flowchart, the only way to find the right boundaries is by doing some trial-and-error work yourself. Which means, by definition, there will be mistakes. There is no way around it! So let’s acknowledge this and only make mistakes that are easy to fix, and try to avoid the fatal ones.

In our experience, it is much safer to extract a service out of a bigger one, than to start with services that are too small. Hence, we prefer to start with bigger boundaries and decompose them later, as more knowledge is acquired about the business. How wide are those initial boundaries? It all goes back to the business domain — the less you know about the business domain, the wider the initial boundaries.
* For more complex domains, start with bigger boundaries, e.g., linguistic or subdomain boundaries.
* Simpler ones, like supporting subdomains, can be decomposed earlier, e.g., into subdomain, or even entity-based boundaries.

However, make sure to extract those smaller contexts – not because you can, but only if you truly need them to deliver some functional or non-functional requirements.

#### Examples
When we tried to decompose to fine-grained services early on, as in the case of Marketing Hub, we ended up with a distributed monolith. On the contrary, the Marketing context started as a very wide one, but was decomposed later on; we extracted Campaigns, Publishers, Creative Catalog, and Events into separate bounded contexts:

(img)

Again, it is evident even here: the simpler the business domain, the narrower its boundaries. 

## Summary
Those are the five pieces of practical advice I wanted to share:
* Ubiquitous language is not optional in any kind of business domain;
* Subdomain types change — so embrace those changes! Use them to make your design more resilient;
* Learn the ins and outs of the four business logic modeling patterns, and use them where each is appropriate;
* Use CQRS to represent data in multiple persistent models, and don’t be too dogmatic about the segregation; and 
* Start with wide bounded context boundaries, and decompose them further when more knowledge of the business domain is acquired — but only if you have good reasons to do so.

### Domain-Driven Design
Our current way of applying domain-driven design is as follows:
![](images/vladikk/hand-drawn/14-ddd.png)

1. We always start by building a ubiquitous language with the domain experts, in order to learn as much as possible about the business domain.
2. In the case of conflicting models, we decompose the solution into bounded contexts, following the linguistic boundaries of the ubiquitous language.
3. We choose an implementation strategy for each subdomain by using the heuristics I’ve shown you.
4. From this design, we deduce the types of business domains at play and verify them with the business. Sometimes this dialog leads to changes in the requirements, because we are able to provide a new perspective on the project to the product owners.
5. As more domain knowledge is acquired, and if needed, we decompose the bounded contexts further into contexts with narrower boundaries.

The main difference between our current vision of domain-driven design and the one we started with is that we went from “Aggregates Everywhere” to *“Ubiquitous Language Everywhere”*.

## P.S.
Since I’ve told you the story of how Internovus started, I want share how it ended.

The company became profitable very quickly, and 7 years after its inception it was acquired by our biggest client. Of course, I cannot attribute its success solely to domain-driven design. However, during those 7 years, we were constantly in “startup mode”. 

What we term “startup mode” in Israel, in the rest of the world is called “chaos”: constantly changing business requirements and priorities, aggressive timeframes, and a tiny R&D team. DDD allowed us to tackle all these complexities and keep delivering working software.

Hence, when I look back, the bet we placed on domain-driven design 7 years ago paid off in full.