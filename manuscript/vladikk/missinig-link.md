# The Missing Link

Let’s be honest: our industry’s track record is pretty bad. The vast majority of software projects fail, either by not meeting the budget, timeframes, or by not delivering expected value. Many researches have been made to identify the reasons for these failures, and their results vary. However, if we look at those findings, there is one central theme repeating itself over and over - communication. Either if it’s stated explicitly — “poor communication”, or implicitly, describing the outcomes:

* “Badly defined system requirements”
* “Poor reporting of the project's status”
* “Unarticulated project goals”
* “Project managers don’t understand users’ needs”
* “Project changes are managed poorly”
* etc

Nothing is really surprising here. For years we’ve been trying to introduce different ways to improve effectiveness of communication: agile methodologies, wikis, chats, and even controversial solutions, such as putting everyone in open spaces. But did we manage to improve our success rates? — No. 

Additional communication mediums didn’t solve our communication problems. Projects keep failing. We have to look for the solution elsewhere.

## Ubiquitous Language

The cornerstone practice of the Domain-Driven Design methodology calls for cultivation of one language, that can be spoken by business people, software engineers, and even source code: Ubiquitous Language.

The first benefit of having such language is trivial. The translation the business people’s mental models into software requirements, and translation of those requirements into technical jargon, is nothing but a broken telephone game.

Having a rigorous ubiquitous language eliminates the need for such translations! Software engineers do not depend on business analysts to interact with domain experts, they can have a conversation with them directly. Even more than that, those domain experts can make sense of the system’s source code. The result? — Both engineers’ mental models, and the source code, aligned much better with the business people’s way of thinking. Hence, less communication issues, and the resulting codebase becomes much easier to maintain and extend.

Another benefit of having a ubiquitous language is a more subtle one. We all know the importance of feedback loops. Agile, Lean, DevOps - all these notions are intended to accelerate different feedback loops. Why are feedback loops so important? Well, because they facilitate communication! The process of cultivating a ubiquitous language is just another feedback loop.     Hence, by increasing the frequency of communication, the quality of communication itself is continually improving as well.

## Conclusion

I’d like to conclude this essay with a quote by one of our time’s brightest minds.

> “If I had an hour to solve a problem I'd spend 55 minutes thinking about  the problem and 5 minutes thinking about solutions” - Albert Einstein

I argue that ubiquitous language is our industry’s missing link. It is the quickest and safest way to truly understand the problems we are solving. Hence, we have to employ this powerful tool on each and every software endeavor.

## References

“Domain-Driven Design: Tackling Complexity in the Heart of Software”, Eric Evans
“Why Software Fails", Robert N. Charette
“Critical Success Factors In Software Projects”, John S. Reel
“An Investigation of Failure in Information Systems Projects: The Case of Jordan”, Rateb J. Sweis
“Critical failure factors in information system projects”, K.T. Yeo
“Critical success factors for software projects: A comparative study”, Mohd Hairul Nizam Nasir and Shamsul Sahibuddin
“Seven Reasons Why Information Technology Projects Fail”, Joseph Gulla, Ph.D.
